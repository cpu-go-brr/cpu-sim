#include "cpu.hpp"
#include "matheval.hpp"
#include <iostream>
#include <assert.h>
#include <regex>
#include <cmath>
#include <cctype>

Description::CPU::CPU(std::string path)
{

    auto file = YAML::LoadFile(path);

    name = file["name"].as<std::string>();
    description = file["description"].as<std::string>("");
    display = file["display"].as<std::string>("");

    auto mem = file["memory"]["internal"];
    for (YAML::const_iterator it = mem.begin(); it != mem.end(); ++it)
    {
        InternalMemory m(it->first.as<std::string>(), it->second, total_mem);
        total_mem += m.size;
        internal_memory.push_back(m);
    }

    mem = file["memory"]["external"];
    for (YAML::const_iterator it = mem.begin(); it != mem.end(); ++it)
    {
        ExternalMemory m(it->first.as<std::string>(), it->second);
        external_memory.push_back(m);
    }

    auto ins = file["instructions"];
    for (YAML::const_iterator it = ins.begin(); it != ins.end(); ++it)
    {
        Instruction m(it->first.as<std::string>(), it->second);
        instructions.push_back(m);
    }

    fetch = Instruction("fetch", file["fetch"]);

    // for (auto m : memory)
    // {
    //     std::cout << m.name << ":" << (m.byteoffset * 8 + m.bitoffset) << "\n";
    //     for (auto m2 : m.submemory)
    //     {
    //         std::cout << m2.name << ":" << (m2.byteoffset * 8 + m2.bitoffset) << "\n";
    //         for (auto m3 : m2.submemory)
    //             std::cout << m3.name << ":" << (m3.byteoffset * 8 + m3.bitoffset) << "\n";
    //     }
    // }
}

std::string Description::CPU::generateHeader()
{
    std::string header =
        "//Autogenerated header for the " + name + "\n"
                                                   "#pragma once\n\n"
                                                   "#include <stdarg.h>\n"
                                                   "#include <stddef.h>\n"
                                                   "#include \"settings.hpp\"\n"
                                                   "#ifndef NO_CPPSTD\n"
                                                   "#include <string>\n"
                                                   "#include <vector>\n\n"
                                                   "#endif\n"
                                                   "#include \"AddressInfo.hpp\"\n"
                                                   "#include \"AddressInfos.hpp\"\n"
                                                   "#include \"bitset.hpp\"\n\n";

    return header;
}

std::string Description::CPU::generateFunctions()
{
    std::string functions = "";

    functions += "   bitset get(AddressInfo info);\n";
    functions += "   void set(bitset data, AddressInfo info);\n";
    functions += "   void set(bitset data, int nums, const AddressInfo* infos);\n";
    functions += "   void set(bitset data, bitset& dest);\n";

    unsigned int max_bits = 0;

    std::map<std::size_t, std::string> instruction_map{};
    for (auto &i : instructions)
    {
        max_bits = std::max(max_bits, i.bits);
        functions += "   template <size_t C>\n";
        functions += "   void " + i.name + "();\n";
    }
    auto array_size = (unsigned int)std::pow(2, max_bits);
    functions += "\nstatic Intel4004::op ops[" + std::to_string(array_size) + "];\n";
    return functions + "\n";
}
std::string Description::CPU::generateMemory()
{
    std::string ret = "   uint8_t memory[" +
                      std::to_string((int)std::ceil(total_mem / 8.0)) + "] = {};\n";

    return ret;
}

std::string getMemoryNames(Description::InternalMemory m)
{
    std::string ret = "";
    ret += m.name + ",";
    for (auto mem : m.submemory)
        ret += getMemoryNames(mem);

    return ret;
}

std::string describeMemory(Description::InternalMemory m)
{
    std::string ret = "const AddressInfo " + m.name + "{" + std::to_string(m.byteoffset) + ", " + std::to_string(m.bitoffset) + ", " + std::to_string(m.size) + "};\n";
    for (auto mem : m.submemory)
        ret += describeMemory(mem);

    return ret;
}

std::string Description::CPU::generateAddressInfos()
{
    std::string ret = "#pragma once\n#include \"AddressInfo.hpp\"\n";

    for (auto m : internal_memory)
    {
        ret += describeMemory(m);
        ret += "\n\n";
    }

    return ret;
}
std::string Description::CPU::lowername()
{
    std::string lowername = name;
    std::for_each(lowername.begin(), lowername.end(), [](char &c)
                  { c = std::tolower(c); });

    return lowername;
}

std::string Description::CPU::generateRunScript()
{

    return "./build.sh\n"
           "./build/" +
           lowername();
}
std::string Description::CPU::generateClass()
{
    std::string c = // class
        "class " + name + "\n"
                          "{\n"
                          "   public:"
                          "   //our internal CPU memory (registers, PC ..)\n" +
        generateMemory() + "\n"
                           "   " +
        name + "();\n\n"
               "   //function pointer\n"
               "   typedef void (" +
        name + "::*op)();\n"
               "\n"
               "void simulate(size_t bytes = 1);\n"
               "char* display();\n"
               "#ifndef NO_CPPSTD\n"
               "std::string json();\n"
               "#endif\n"
               "bitset fetch();\n";

    for (auto m : external_memory)
        c += m.getDeclaration();

    //    "bitset rom(bitset val);\n"
    //    "uint8_t* ram(bitset val);\n"
    c +=
        "void bin(AddressInfo info, char* addr);\n"
        "void hex(AddressInfo info, char* addr);\n"
        "void dec(AddressInfo info, char* addr);\n"
        "   //functions\n" +
        generateFunctions() +
        "char* str = NULL;"
        "};";

    return c;
}

std::size_t unescapedsize(std::string s)
{
    // \\.
    std::size_t len = s.size() - 1;

    std::smatch m;
    std::regex e("\n"); // matches words beginning by "sub"

    while (std::regex_search(s, m, e))
    {
        len -= 3;
        s = m.suffix().str();
    }
    return len;
}

std::string Description::CPU::generateDisplay()
{
    // replace our display:

    auto display_str = std::regex_replace(display, std::regex("\\n"), "\\n\\\n");

    std::regex replacements("(0x|0b)?\\{([A-Z][A-Z0-9]+)\\}");
    std::smatch sm;

    std::string params = "";
    std::size_t size = display.length() + 1;
    while (std::regex_search(display_str, sm, replacements))
    {
        size -= sm[1].str().size();
        auto b = InternalMemory::address_lengths[sm[2].str()];
        auto c = 0;
        if (sm[1].str() == "")
        {
            c = (std::size_t)std::ceil(std::log10(std::pow(2, b)));
            params += "dec(" + sm[2].str() + ", str+" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        if (sm[1].str() == "0x")
        {
            c = (std::size_t)std::ceil(b / 4.0);
            params += "hex(" + sm[2].str() + ",str +" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        if (sm[1].str() == "0b")
        {
            c = b;
            params += "bin(" + sm[2].str() + ", str +" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        size += c;
        std::string placeholder = "";
        for (int i = 0u; i < c; i++)
            placeholder += "X";
        display_str = sm.prefix().str() + placeholder + sm.suffix().str();
    }

    std::string ret;

    ret += "void " + name + "::bin(AddressInfo info, char* addr)\n{\n\
       get(info).bin(addr);\n\
    }\n";

    ret += "void " + name + "::hex(AddressInfo info, char* addr)\n{\n\
       get(info).hex(addr);\n\
    }\n";

    ret += "void " + name + "::dec(AddressInfo info, char* addr)\n{\n\
       get(info).dec(addr);\n\
    }\n";

    ret += "char* " + name + "::display()\n";
    ret += "{\n";
    ret += "if(str == NULL)\n"
           "{\nstr = (char*)malloc(" +
           std::to_string(unescapedsize(display_str) - 2) + ");\n"
                                                            "sprintf(str, " +
           display_str + ");\n"
                         "}\n";
    ret += params;
    ret += "#ifndef NO_PRINT\n";
    ret += "printf(\"%s\",str);\n";
    ret += "#endif\n";
    ret += "return str;\n";
    ret += "}\n";

    return ret;
}
std::string Description::CPU::generateCMakeFile()
{
    std::string ret = ""
                      "cmake_minimum_required(VERSION 3.0) # setting this is required\n"
                      "project(" +
                      name + ")            # this sets the project name\n"
                             "file(GLOB_RECURSE sources src/*.cpp include/*.hpp)\n"
                             "add_executable(" +
                      lowername() + " ${sources})\n"
                                    "target_compile_options(" +
                      lowername() + " PUBLIC -std=c++2a -Wall -Wfloat-conversion)\n"
                                    "target_include_directories(" +
                      lowername() + " PUBLIC include)\n"
                                    "install(TARGETS " +
                      lowername() + " DESTINATION bin)\n"
                                    "install(DIRECTORY resources DESTINATION bin)\n"
                                    "set(CPACK_PACKAGE_NAME \"" +
                      name + "\")\n"
                             "set(CPACK_PACKAGE_VERSION \"1.0.0\")\n"
                             "set(CPACK_MONOLITHIC_INSTALL 1)\n"
                             "include(CPack)\n";

    return ret;
}

std::string Description::CPU::generateHpp()
{
    return generateHeader() + generateClass();
}

std::string Description::CPU::generateCpp()
{
    std::string cpp = "";

    cpp += "#include \"" + name + ".hpp\"\n";
    cpp += "#include <stdio.h>\n";
    cpp += "#include <stdlib.h>\n";

    cpp += "bitset " + name + "::get(AddressInfo info)\n"
                              "{\n"
                              "   return get_mem(&memory[0], info);\n"
                              "}\n";
    for (auto i : instructions)
    {
        cpp += "/* " + i.description + "*/\n";
        cpp += i.getFunction(name) + "\n";
    }

    unsigned int max_bits = 0;
    std::map<std::size_t, std::string> instruction_map{};
    for (auto &i : instructions)
    {
        max_bits = std::max(max_bits, i.bits);
        for (auto &code : i.getOPCodes())
            instruction_map[std::stoi(code.c_str(), nullptr, 2)] = "&" + name + "::" + i.name + "<0b" + code + ">";
    }
    auto array_size = (unsigned int)std::pow(2, max_bits);
    cpp += "Intel4004::op " + name + "::" + "ops[" + std::to_string(array_size) + "] = {\n";
    for (auto i = 0u; i < array_size; i++)
    {
        if (instruction_map.contains(i))
            cpp += instruction_map[i];
        else
            cpp += "NULL";

        if (i != array_size - 1)
            cpp += ",\n";
    }

    cpp += "};\n";

    cpp += name + "::" + name + "()\n{\n";
    for (auto &m : external_memory)
    {
        cpp += m.getInit();
    }
    cpp += "\n}\n";

    cpp += generateDisplay();

    cpp += "void " + name + "::simulate(size_t i)\n{\n"
                            "for (;i-->0;)\n"
                            "{\n"
                            "   auto val = fetch();\n"
                            "   if(ops[val.val()] == NULL)\n"
                            "   {\n"
                            "   #ifndef NO_PRINT\n"
                            "   fprintf(stderr, \"%zx unknown\\n\", val.val());\n"
                            "   #endif\n"
                            "   break;\n"
                            "   }\n"
                            "   (this->*ops[val.val()])();\n"
                            "}\n";
    cpp += "}\n";

    for (auto m : external_memory)
    {
        cpp += m.getFunction(name);
    }

    cpp += "bitset " + name + "::fetch()\n"
                              "{\n" +
           fetch.getCode(name) +
           "}\n";

    cpp += "void " + name + "::set(bitset data, AddressInfo info)\n{\nset_mem(&memory[0], info, data);\n}\n";
    cpp += "void " + name + "::set(bitset data, bitset& dest)\n{\ndest=data;\n}\n";
    cpp += "void " + name + "::set(bitset data, int num, const AddressInfo* infos)\n{\n"
                            "for(size_t i = num; i --> 0;)\n"
                            "{\n"
                            "set_mem(&memory[0], infos[i], data);\n"
                            "data = data >> infos[i].length;\n"
                            "}\n}\n";

    cpp += "#ifndef NO_CPPSTD\n"
           "    std::string Intel4004::json()\n"
           "{\n"
           "std::string json = \"{\\\"internal\\\":{\"\n";
    for (auto m : internal_memory)
    {
        cpp += m.getJSONDescription() + "\n";
    }

    cpp = cpp.substr(0, cpp.size() - 3) + "},\\\"external\\\":{\"\n";
    for (auto m : external_memory)
    {
        cpp += "\"\\\"" + m.name + "\\\":{\\\"bits\\\":" + std::to_string(m.bits) + ",\\\"vals\\\":[\";\n";
        cpp += "for(size_t i = 0; i < " + std::to_string(m.words) + "; i++) json += std::to_string(" + m.name + "_mem[i].val()) + \",\";\n"
                                                                                                                "json = json.substr(0,json.size()-1);\n";
        cpp += "json += \"]},\";\njson +=";
    }
    cpp = cpp.substr(0, cpp.size() - 12) + "\"\n\"}}\";\n";
    cpp += "return json + \"}\";\n}\n#endif\n";

    return cpp;
}
