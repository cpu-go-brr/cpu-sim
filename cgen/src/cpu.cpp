#include "cpu.hpp"
#include "matheval.hpp"
#include <iostream>
#include <assert.h>
#include <regex>
#include <cmath>
#include <cctype>

void CPUDescription::CPU::initInfo(const YAML::Node &config)
{
    name = config["name"].as<std::string>();
    description = config["description"].as<std::string>("");
    display = config["display"].as<std::string>("");
}

void CPUDescription::CPU::initInternalMemory(const YAML::Node &config)
{
    auto mem = config["memory"]["internal"];
    for (YAML::const_iterator it = mem.begin(); it != mem.end(); ++it)
    {
        InternalMemory m(it->first.as<std::string>(), it->second, total_mem);
        total_mem += m.size;
        internal_memory.push_back(m);
    }
}

void CPUDescription::CPU::initExternalMemory(const YAML::Node &config)
{
    auto mem = config["memory"]["external"];
    for (YAML::const_iterator it = mem.begin(); it != mem.end(); ++it)
    {
        ExternalMemory m(it->first.as<std::string>(), it->second);
        external_memory.push_back(m);
    }
}

void CPUDescription::CPU::initInstructions(const YAML::Node &config)
{
    auto ins = config["instructions"];
    for (YAML::const_iterator it = ins.begin(); it != ins.end(); ++it)
    {
        Instruction m(it->first.as<std::string>(), it->second);
        instructions.push_back(m);
    }

    fetch = Instruction("fetch", config["fetch"]);
}

CPUDescription::CPU::CPU(std::string path)
{
    auto file = YAML::LoadFile(path);
    initInfo(file);
    initInternalMemory(file);
    initExternalMemory(file);
    initInstructions(file);
}

std::string CPUDescription::CPU::generateHppIncludes()
{
    return "//Autogenerated header for the " + name + "\n"
                                                      "#pragma once\n\n"
                                                      "#include <stdarg.h>\n"
                                                      "#include <stddef.h>\n"
                                                      "#include \"settings.hpp\"\n"
                                                      "#ifndef NO_CPPSTD\n"
                                                      "#include <string>\n"
                                                      "#include <vector>\n\n"
                                                      "#endif\n"
                                                      "#include \"AddressInfo.hpp\"\n"
                                                      "#include \"AddressInfos.hpp\"\n"
                                                      "#include \"bitset.hpp\"\n\n";
}

std::string CPUDescription::CPU::generateHppInstructions()
{
    std::string functions = ""; // the return array
    std::size_t max_bits = 0;  // the maximum number of bits a function has

    for (auto &i : instructions)
    {
        max_bits = std::max(max_bits, i.getSizeOfOPCode());  // set the bitsize to maximum
        functions += "   template <size_t C>\n" // concatenate declaration of the instruction
                     "   void " + i.getName() + "();\n";
    }
    auto array_size = (unsigned int)std::pow(2, max_bits);                            // calculate space needed o accommodate all instructions
    functions += "\nstatic Intel4004::op ops[" + std::to_string(array_size) + "];\n"; // add array for instruction pointer
    return functions + "\n";
}

std::string CPUDescription::CPU::generateMemory()
{
    //return byte array needed to accommodate all internal memory
    return "   uint8_t memory[" + std::to_string((int)std::ceil(total_mem / 8.0)) + "] = {};\n";
}


std::string getAddressInfo(CPUDescription::InternalMemory m)
{
    std::string ret = "const AddressInfo " + m.name + "{" + std::to_string(m.byteoffset) + ", " + std::to_string(m.bitoffset) + ", " + std::to_string(m.size) + "};\n";
    for (auto mem : m.submemory)
        ret += getAddressInfo(mem);

    return ret + "\n\n";
}

std::string CPUDescription::CPU::generateAddressInfos()
{
    std::string ret = "#pragma once\n#include \"AddressInfo.hpp\"\n";

    for (auto m : internal_memory)
        ret += getAddressInfo(m);

    return ret;
}
std::string CPUDescription::CPU::getName()
{
    return name;
}
std::string CPUDescription::CPU::getDescription()
{
    return description;
}
std::string CPUDescription::CPU::getLowerName()
{
    std::string lowername = name;
    std::for_each(lowername.begin(), lowername.end(), [](char &c)
                  { c = std::tolower(c); });

    return lowername;
}

std::string CPUDescription::CPU::generateRunScript()
{
    return "./build.sh\n"
           "./build/" +
           getLowerName();
}
std::string CPUDescription::CPU::generateClass()
{
    std::string c = // class
        "class " + name + "\n"
                          "{\n"
                          "   public:"
                          "   //our internal CPU memory (registers, PC ..)\n" +
        generateMemory() + "\n"
                           "   " +
        name + "();\n\n"
               "   //function pointer\n"
               "   typedef void (" +
        name + "::*op)();\n"
               "\n"
               "void simulate(size_t bytes = 1);\n"
               "char* display();\n"
               "#ifndef NO_CPPSTD\n"
               "std::string json();\n"
               "#endif\n"
               "bitset fetch();\n"
               "bitset get(AddressInfo info);\n"
               "void set(bitset data, AddressInfo info);\n"
               "void set(bitset data, int nums, const AddressInfo* infos);\n"
               "void set(bitset data, bitset& dest);\n";

    for (auto m : external_memory)
        c += m.getInterfaceDeclaration();

    c +=
        "void bin(AddressInfo info, char* addr);\n"
        "void hex(AddressInfo info, char* addr);\n"
        "void dec(AddressInfo info, char* addr);\n"
        "   //functions\n" +
        generateHppInstructions() +
        "char* str = NULL;"
        "};";

    return c;
}

//returns stringsize -1 -3*count('\n')
std::size_t unescapedsize(std::string s)
{
    std::size_t len = s.size() - 1;
    std::smatch m;
    std::regex e("\n"); // matches words beginning by "sub"

    while (std::regex_search(s, m, e))
    {
        len -= 3;
        s = m.suffix().str();
    }
    return len;
}

std::string CPUDescription::CPU::generateDisplay()
{
    // replace our display:
    auto display_str = std::regex_replace(display, std::regex("\\n"), "\\n\\\n"); //escape \n

    std::regex replacements("(0x|0b)?\\{([A-Z][A-Z0-9]+)\\}"); //matchs 0x{PC} 0b{ACC} {R0} ..
    std::smatch sm;

    std::string params = "";
    std::size_t size = display.length() + 1;
    while (std::regex_search(display_str, sm, replacements))
    {
        size -= sm[1].str().size();
        auto b = InternalMemory::address_lengths[sm[2].str()];
        auto c = 0;
        if (sm[1].str() == "")
        {
            c = (std::size_t)std::ceil(std::log10(std::pow(2, b)));
            params += "dec(" + sm[2].str() + ", str+" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        if (sm[1].str() == "0x")
        {
            c = (std::size_t)std::ceil(b / 4.0);
            params += "hex(" + sm[2].str() + ",str +" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        if (sm[1].str() == "0b")
        {
            c = b;
            params += "bin(" + sm[2].str() + ", str +" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        size += c;
        std::string placeholder = "";
        for (int i = 0u; i < c; i++)
            placeholder += "X";
        display_str = sm.prefix().str() + placeholder + sm.suffix().str();
    }

    std::string ret;

    ret += "void " + name + "::bin(AddressInfo info, char* addr)\n{\n\
       get(info).bin(addr);\n\
    }\n";

    ret += "void " + name + "::hex(AddressInfo info, char* addr)\n{\n\
       get(info).hex(addr);\n\
    }\n";

    ret += "void " + name + "::dec(AddressInfo info, char* addr)\n{\n\
       get(info).dec(addr);\n\
    }\n";

    ret += "char* " + name + "::display()\n";
    ret += "{\n";
    ret += "if(str == NULL)\n"
           "{\nstr = (char*)malloc(" +
           std::to_string(unescapedsize(display_str) - 2) + ");\n"
                                                            "sprintf(str, " +
           display_str + ");\n"
                         "}\n";
    ret += params;
    ret += "#ifndef NO_PRINT\n";
    ret += "printf(\"%s\",str);\n";
    ret += "#endif\n";
    ret += "return str;\n";
    ret += "}\n";

    return ret;
}
std::string CPUDescription::CPU::generateCMakeFile()
{
    std::string ret = ""
                      "cmake_minimum_required(VERSION 3.0) # setting this is required\n"
                      "project(" +
                      name + ")            # this sets the project name\n"
                             "file(GLOB_RECURSE sources src/*.cpp include/*.hpp)\n"
                             "add_executable(" +
                      getLowerName() + " ${sources})\n"
                                       "target_compile_options(" +
                      getLowerName() + " PUBLIC -std=c++2a -Wall -Wfloat-conversion)\n"
                                       "target_include_directories(" +
                      getLowerName() + " PUBLIC include)\n"
                                       "install(TARGETS " +
                      getLowerName() + " DESTINATION bin)\n"
                                       "install(DIRECTORY resources DESTINATION bin)\n"
                                       "set(CPACK_PACKAGE_NAME \"" +
                      name + "\")\n"
                             "set(CPACK_PACKAGE_VERSION \"1.0.0\")\n"
                             "set(CPACK_MONOLITHIC_INSTALL 1)\n"
                             "include(CPack)\n";

    return ret;
}

std::string CPUDescription::CPU::generateHpp()
{
    return generateHppIncludes() + generateClass();
}

std::string CPUDescription::CPU::generateCpp()
{
    std::string cpp = "";

    cpp += "#include \"" + name + ".hpp\"\n";
    cpp += "#include <stdio.h>\n";
    cpp += "#include <stdlib.h>\n";

    cpp += "bitset " + name + "::get(AddressInfo info)\n"
                              "{\n"
                              "   return get_mem(&memory[0], info);\n"
                              "}\n";
    for (auto i : instructions)
    {
        cpp += "/* " + i.getDescription() + "*/\n";
        cpp += i.getCode(name) + "\n";
    }

    std::size_t max_opcode_size = 0;
    std::map<std::size_t, std::string> instruction_map{};
    for (auto &i : instructions)
    {
        max_opcode_size = std::max(max_opcode_size, i.getSizeOfOPCode());
        for (auto &code : i.getOPCodes())
            instruction_map[std::stoi(code.c_str(), nullptr, 2)] = "&" + name + "::" + i.getName() + "<0b" + code + ">";
    }
    auto array_size = (unsigned int)std::pow(2, max_opcode_size);
    cpp += "Intel4004::op " + name + "::" + "ops[" + std::to_string(array_size) + "] = {\n";
    for (auto i = 0u; i < array_size; i++)
    {
        if (instruction_map.contains(i))
            cpp += instruction_map[i];
        else
            cpp += "NULL";

        if (i != array_size - 1)
            cpp += ",\n";
    }

    cpp += "};\n";

    cpp += name + "::" + name + "()\n{\n";
    for (auto &m : external_memory)
    {
        cpp += m.getInitCode();
    }
    cpp += "\n}\n";

    cpp += generateDisplay();

    cpp += "void " + name + "::simulate(size_t i)\n{\n"
                            "for (;i-->0;)\n"
                            "{\n"
                            "   auto val = fetch();\n"
                            "   if(ops[val.val()] == NULL)\n"
                            "   {\n"
                            "   #ifndef NO_PRINT\n"
                            "   fprintf(stderr, \"%zx unknown\\n\", val.val());\n"
                            "   #endif\n"
                            "   break;\n"
                            "   }\n"
                            "   (this->*ops[val.val()])();\n"
                            "}\n";
    cpp += "}\n";

    for (auto m : external_memory)
    {
        cpp += m.getInterfaceCode(name);
    }

    cpp += "bitset " + name + "::fetch()\n"
                              "{\n" +
           fetch.generateFunction(name) +
           "}\n";

    cpp += "void " + name + "::set(bitset data, AddressInfo info)\n{\nset_mem(&memory[0], info, data);\n}\n";
    cpp += "void " + name + "::set(bitset data, bitset& dest)\n{\ndest=bitset(data,dest.size());\n}\n";
    cpp += "void " + name + "::set(bitset data, int num, const AddressInfo* infos)\n{\n"
                            "for(size_t i = num; i --> 0;)\n"
                            "{\n"
                            "set_mem(&memory[0], infos[i], data);\n"
                            "data = data >> infos[i].length;\n"
                            "}\n}\n";

    cpp += "#ifndef NO_CPPSTD\n"
           "    std::string Intel4004::json()\n"
           "{\n"
           "std::string json = \"{\\\"internal\\\":{\"\n";
    for (auto m : internal_memory)
    {
        cpp += m.getJSONDescription() + "\n";
    }

    cpp = cpp.substr(0, cpp.size() - 3) + "},\\\"external\\\":{\"\n";
    for (auto m : external_memory)
    {
        cpp += "\"\\\"" + m.getName() + "\\\":{\\\"bits\\\":" + std::to_string(m.getBits()) + ",\\\"vals\\\":[\";\n";
        cpp += "for(size_t i = 0; i < " + std::to_string(m.getWords()) + "; i++) json += std::to_string(" + m.getName() + "_mem[i].val()) + \",\";\n"
                                                                                                                "json = json.substr(0,json.size()-1);\n";
        cpp += "json += \"]},\";\njson +=";
    }
    cpp = cpp.substr(0, cpp.size() - 12) + "\"\n\"}}\";\n";
    cpp += "return json + \"}\";\n}\n#endif\n";

    return cpp;
}
