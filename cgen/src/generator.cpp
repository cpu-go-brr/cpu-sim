#include "cpu.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <cmath>

std::string Description::CPU::generateHeader()
{
    std::string header =
        "//Autogenerated header for the " + name + "\n"
                                                   "#pragma once\n\n"
                                                   "#include <stdarg.h>\n"
                                                   "#include \"settings.hpp\"\n"
                                                   "#ifndef C_ONLY\n"
                                                   "#include <string>\n"
                                                   "#include <vector>\n\n"
                                                   "#endif\n"
                                                   "#include \"AddressInfo.hpp\"\n"
                                                   "#include \"AddressInfos.hpp\"\n"
                                                   "#include \"bitset.hpp\"\n\n"
                                                   "#include \"size_t.hpp\"\n\n";

    return header;
}

std::string Description::CPU::generateFunctions()
{
    std::string functions = "";

    functions += "   bitset get(AddressInfo info);\n";
    functions += "   void set(bitset data, AddressInfo info);\n";
    functions += "   void set(bitset data, int nums, ...);\n";
    functions += "   void set(bitset data, bitset& dest);\n";

    unsigned int max_bits = 0;


    std::map<std::size_t, std::string> instruction_map{};
    for (auto &i : instructions)
    {
        max_bits = std::max(max_bits,i.bits);
        functions += "   template <SIZE_T C>\n";
        functions += "   void " + i.name + "();\n";
    }
    auto array_size = (unsigned int)std::pow(2,max_bits);
    functions += "\nstatic Intel4004::op ops["+std::to_string(array_size)+"];\n";
    return functions + "\n";
}
std::string Description::CPU::generateMemory()
{
    std::string ret = "   uint8_t memory[" +
                      std::to_string((int)std::ceil(total_mem / 8.0)) + "] = {};\n";

    return ret;
}

std::string getMemoryNames(Description::InternalMemory m)
{
    std::string ret = "";
    ret += m.name + ",";
    for (auto mem : m.submemory)
        ret += getMemoryNames(mem);

    return ret;
}

std::string describeMemory(Description::InternalMemory m)
{
    std::string ret = "const AddressInfo " + m.name + "{" + std::to_string(m.byteoffset) + ", " + std::to_string(m.bitoffset) + ", " + std::to_string(m.size) + "};\n";
    for (auto mem : m.submemory)
        ret += describeMemory(mem);

    return ret;
}

std::string Description::CPU::generateAddressInfos()
{
    std::string ret = "#pragma once\n#include \"AddressInfo.hpp\"\n";

    for (auto m : internal_memory)
    {
        ret += describeMemory(m);
        ret += "\n\n";
    }

    return ret;
}

std::string Description::CPU::generateClass()
{
    std::string c = // class
        "class " + name + "\n"
                          "{\n"
                          "   public:"
                          "   //our internal CPU memory (registers, PC ..)\n" +
        generateMemory() + "\n"
                           "   " +
        name + "();\n\n"
               "   //function pointer\n"
               "   typedef void (" +
        name + "::*op)();\n"
               "\n"
               "void simulate(std::size_t bytes = 1);\n"
               "void display();\n"
               "bitset fetch();\n";

    for (auto m : external_memory)
        c += m.getDeclaration();

    //    "bitset rom(bitset val);\n"
    //    "uint8_t* ram(bitset val);\n"
    c +=
        "const char* bin(AddressInfo info);\n"
        "const char* hex(AddressInfo info);\n"
        "const char* dec(AddressInfo info);\n"
        "   //functions\n" +
        generateFunctions() +
        "};";

    return c;
}

std::string Description::CPU::generateMainFile()
{
    std::string ret = "#include \"" + name + ".hpp\"\n";

    ret += "int main (int argc, char** argv)\n";
    ret += "{\n";
    ret += name + " cpu;\n";
    ret += "return 0;\n";
    ret += "}\n";

    return ret;
}

std::string Description::CPU::generateDisplay()
{
    // replace our display:

    auto display_str = display;

    std::regex replacements("(0x|0b)?\\{([A-Z][A-Z0-9]+)\\}");
    std::smatch sm;

    std::string params = "";

    while (std::regex_search (display_str,sm,replacements)) 
    {
        if(sm[1].str() == "") params += "dec("+sm[2].str()+"),";
        if(sm[1].str() == "0x") params += "hex("+sm[2].str()+"),";
        if(sm[1].str() == "0b") params += "bin("+sm[2].str()+"),";
        display_str = sm.prefix().str()  + "%s" + sm.suffix().str();
    }

    params = params.substr(0,params.size()-1);

    // display_str = std::regex_replace(display_str, bin, "\" + bin( $1 ) + \"");
    // display_str = std::regex_replace(display_str, hex, "\" + hex( $1 ) + \"");
    // display_str = std::regex_replace(display_str, dec, "\" + dec( $1 ) + \"");

    std::string ret;

    ret += "const char* " + name + "::bin(AddressInfo info)\n{\n\
       return get(info).bin();\n\
    }\n";

    ret += "const char* " + name + "::hex(AddressInfo info)\n{\n\
       return get(info).hex();\n\
    }\n";

    ret += "const char* " + name + "::dec(AddressInfo info)\n{\n\
       return get(info).dec();\n\
    }\n";

    ret += "void " + name + "::display()\n";
    ret += "{\n";
    ret += "#ifndef NO_PRINT\n";
    ret += "printf("+display_str+","+params+");\n";
    ret += "#endif\n";
    ret += "}\n";

    return ret;
}
std::string Description::CPU::generateCMakeFile()
{
    std::string ret = "  "
                      "cmake_minimum_required(VERSION 3.0) # setting this is required\n"
                      "project(" +
                      name + ")            # this sets the project name\n"
                             "file(GLOB_RECURSE sources src/*.cpp include/*.hpp)\n"
                             "add_executable(simulator ${sources})\n"
                             "target_compile_options(simulator PUBLIC -std=c++2a -Wall -Wfloat-conversion)\n"
                             "target_include_directories(simulator PUBLIC include)\n"
                             "install(TARGETS simulator DESTINATION bin)\n"
                             "install(DIRECTORY resources DESTINATION bin)\n"
                             "set(CPACK_PACKAGE_NAME \"" +
                      name + "\")\n"
                             "set(CPACK_PACKAGE_VERSION \"1.0.0\")\n"
                             "set(CPACK_MONOLITHIC_INSTALL 1)\n"
                             "include(CPack)\n";

    return ret;
}

void Description::CPU::generate()
{

    std::filesystem::copy("resources/", "out/", std::filesystem::copy_options::recursive | std::filesystem::copy_options::overwrite_existing);

    std::filesystem::create_directory("out");
    std::ofstream hpp("out/include/" + name + ".hpp", std::ios::trunc);

    hpp << generateHeader();
    hpp << generateClass();
    hpp.close();

    std::ofstream info("out/include/AddressInfos.hpp", std::ios::trunc);
    info << generateAddressInfos();
    info.close();

    std::ofstream cpp("out/src/" + name + ".cpp", std::ios::trunc);
    cpp << "#include \"" + name + ".hpp\"\n";

    cpp << "bitset " + name + "::get(AddressInfo info)\n"
                              "{\n"
                              "   return get_mem(&memory[0], info);\n"
                              "}\n";
    for (auto i : instructions)
    {
        cpp << "/* " << i.description << "*/\n";
        cpp << i.getFunction(name) << "\n";
    }


    unsigned int max_bits = 0;
    std::map<std::size_t, std::string> instruction_map{};
    for (auto &i : instructions)
    {
        max_bits = std::max(max_bits,i.bits);
        for(auto& code : i.getOPCodes())
            instruction_map[std::stoi(code.c_str(), nullptr, 2)] = "&" + name + "::" + i.name + "<0b"+ code + ">";
    }
    auto array_size = (unsigned int)std::pow(2,max_bits);
    cpp << "Intel4004::op " + name + "::" + "ops["+std::to_string(array_size)+"] = {\n";
    for(auto i = 0u; i < array_size; i++)
    {
        if(instruction_map.contains(i))
            cpp << instruction_map[i];
        else
            cpp << "NULL";

        if(i != array_size -1) cpp << ",\n";
    }



    cpp << "};\n";

    cpp << name + "::" + name + "()\n{\n";
    for (auto &m : external_memory)
    {
        cpp << m.getInit();
    }
    cpp << "\n}\n";

    cpp << generateDisplay();

    cpp << "void " + name + "::simulate(std::size_t i)\n{\n"
                            "for (;i-->0;)\n"
                            "{\n"
                            "   auto val = fetch();\n"
                            "   if(ops[val.val()] == NULL)\n"
                            "   {\n"
                            "   #ifndef NO_PRINT\n"
                            "   fprintf(stderr, \"%s unknown\\n\", val.bin());\n"
                            "   #endif\n"
                            "   break;\n"
                            "   }\n"
                            "   (this->*ops[val.val()])();\n"
                            "}\n";
    cpp << "}\n";

    for (auto m : external_memory)
    {
        cpp << m.getFunction(name);
    }

    cpp << "bitset " + name + "::fetch()\n"
                              "{\n" +
               fetch.getCode(name) +
               "}\n";

    cpp << "void " + name + "::set(bitset data, AddressInfo info)\n{\nset_mem(&memory[0], info, data);\n}\n";
    cpp << "void " + name + "::set(bitset data, bitset& dest)\n{\ndest=data;\n}\n";
    cpp << "void " + name + "::set(bitset data, int num, ...)\n{\n"
                            "va_list valist;\n"
                            "va_start(valist, num);\n"
                            "for(SIZE_T i = num; i --> 0;)\n"
                            "{\n"
                            "AddressInfo info = va_arg(valist, AddressInfo);\n"
                            "set_mem(&memory[0], info, data);\n"
                            "data = data >> info.length;\n"
                            "va_end(valist);\n"
                            "}\n}\n";

    cpp.close();

    std::ofstream cmake("out/CMakeLists.txt", std::ios::trunc);
    cmake << generateCMakeFile();
    cmake.close();

    // std::ofstream main("out/src/main.cpp", std::ios::trunc);
    // main << generateMainFile();
    // main.close();
}