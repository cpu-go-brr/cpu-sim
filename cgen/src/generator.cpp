#include "cpu.hpp"
#include <filesystem>
#include <fstream>
#include <iostream>
#include <cmath>

std::string Description::CPU::generateHeader()
{
    std::string header =
        "//Autogenerated header for the " + name + "\n"
                                                   "#pragma once\n\n"
                                                   "#include <stdarg.h>\n"
                                                   "#include <stddef.h>\n"
                                                   "#include \"settings.hpp\"\n"
                                                   "#ifndef C_ONLY\n"
                                                   "#include <string>\n"
                                                   "#include <vector>\n\n"
                                                   "#endif\n"
                                                   "#include \"AddressInfo.hpp\"\n"
                                                   "#include \"AddressInfos.hpp\"\n"
                                                   "#include \"bitset.hpp\"\n\n"
                                                   "#include \"size_t.hpp\"\n\n";

    return header;
}

std::string Description::CPU::generateFunctions()
{
    std::string functions = "";

    functions += "   bitset get(AddressInfo info);\n";
    functions += "   void set(bitset data, AddressInfo info);\n";
    functions += "   void set(bitset data, int nums, const AddressInfo* infos);\n";
    functions += "   void set(bitset data, bitset& dest);\n";

    unsigned int max_bits = 0;


    std::map<std::size_t, std::string> instruction_map{};
    for (auto &i : instructions)
    {
        max_bits = std::max(max_bits,i.bits);
        functions += "   template <SIZE_T C>\n";
        functions += "   void " + i.name + "();\n";
    }
    auto array_size = (unsigned int)std::pow(2,max_bits);
    functions += "\nstatic Intel4004::op ops["+std::to_string(array_size)+"];\n";
    return functions + "\n";
}
std::string Description::CPU::generateMemory()
{
    std::string ret = "   uint8_t memory[" +
                      std::to_string((int)std::ceil(total_mem / 8.0)) + "] = {};\n";

    return ret;
}

std::string getMemoryNames(Description::InternalMemory m)
{
    std::string ret = "";
    ret += m.name + ",";
    for (auto mem : m.submemory)
        ret += getMemoryNames(mem);

    return ret;
}

std::string describeMemory(Description::InternalMemory m)
{
    std::string ret = "const AddressInfo " + m.name + "{" + std::to_string(m.byteoffset) + ", " + std::to_string(m.bitoffset) + ", " + std::to_string(m.size) + "};\n";
    for (auto mem : m.submemory)
        ret += describeMemory(mem);

    return ret;
}

std::string Description::CPU::generateAddressInfos()
{
    std::string ret = "#pragma once\n#include \"AddressInfo.hpp\"\n";

    for (auto m : internal_memory)
    {
        ret += describeMemory(m);
        ret += "\n\n";
    }

    return ret;
}

std::string Description::CPU::generateClass()
{
    std::string c = // class
        "class " + name + "\n"
                          "{\n"
                          "   public:"
                          "   //our internal CPU memory (registers, PC ..)\n" +
        generateMemory() + "\n"
                           "   " +
        name + "();\n\n"
               "   //function pointer\n"
               "   typedef void (" +
        name + "::*op)();\n"
               "\n"
               "void simulate(SIZE_T bytes = 1);\n"
               "char* display();\n"
               "bitset fetch();\n";

    for (auto m : external_memory)
        c += m.getDeclaration();

    //    "bitset rom(bitset val);\n"
    //    "uint8_t* ram(bitset val);\n"
    c +=
        "void bin(AddressInfo info, char* addr);\n"
        "void hex(AddressInfo info, char* addr);\n"
        "void dec(AddressInfo info, char* addr);\n"
        "   //functions\n" +
        generateFunctions() +
        "char* str = NULL;"
        "};";

    return c;
}

std::string Description::CPU::generateMainFile()
{
    std::string ret = "#include \"" + name + ".hpp\"\n";

    ret += "int main (int argc, char** argv)\n";
    ret += "{\n";
    ret += name + " cpu;\n";
    ret += "return 0;\n";
    ret += "}\n";

    return ret;
}

std::size_t unescapedsize(std::string s)
{
    // \\.
    std::size_t len = s.size()-1;

      std::smatch m;
  std::regex e ("\n");   // matches words beginning by "sub"

  while (std::regex_search (s,m,e)) 
  {
    len-=3;
    s = m.suffix().str();
  }
  return len;
}

std::string Description::CPU::generateDisplay()
{
    // replace our display:

    auto display_str = std::regex_replace(display,std::regex("\\n"),"\\n\\\n");

    std::regex replacements("(0x|0b)?\\{([A-Z][A-Z0-9]+)\\}");
    std::smatch sm;

    std::string params = "";
    std::size_t size = display.length()+1;
    while (std::regex_search (display_str,sm,replacements)) 
    {
        size -= sm[1].str().size();
        auto b = InternalMemory::address_lengths[sm[2].str()];
        auto c = 0;
        if(sm[1].str() == "") 
        {
            c = (std::size_t)std::ceil(std::log10(std::pow(2,b)));
            params += "dec("+sm[2].str()+", str+" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        if(sm[1].str() == "0x") 
        {
            c = (std::size_t)std::ceil(b / 4.0);
            params += "hex("+sm[2].str()+",str +" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        if(sm[1].str() == "0b") 
        {
            c = b;
            params += "bin("+sm[2].str()+", str +" + std::to_string(unescapedsize(sm.prefix().str())) + ");\n";
        }
        size+=c;
        std::string placeholder ="";
        for(int i = 0u; i < c; i++) placeholder += "X";
        display_str = sm.prefix().str()  + placeholder + sm.suffix().str();
    }

    std::string ret;

    ret += "void " + name + "::bin(AddressInfo info, char* addr)\n{\n\
       get(info).bin(addr);\n\
    }\n";

    ret += "void " + name + "::hex(AddressInfo info, char* addr)\n{\n\
       get(info).hex(addr);\n\
    }\n";

    ret += "void " + name + "::dec(AddressInfo info, char* addr)\n{\n\
       get(info).dec(addr);\n\
    }\n";

    ret += "char* " + name + "::display()\n";
    ret += "{\n";
    ret += "if(str == NULL)\n" 
            "{\nstr = (char*)malloc(" + std::to_string(unescapedsize(display_str)-2) + ");\n"
            "sprintf(str, " + display_str + ");\n"
            "}\n";
    ret += params;
    ret += "#ifndef NO_PRINT\n";
    ret += "printf(\"%s\",str);\n";
    ret += "#endif\n";
    ret += "return str;\n";
    ret += "}\n";

    return ret;
}
std::string Description::CPU::generateCMakeFile()
{
    std::string ret = "  "
                      "cmake_minimum_required(VERSION 3.0) # setting this is required\n"
                      "project(" +
                      name + ")            # this sets the project name\n"
                             "file(GLOB_RECURSE sources src/*.cpp include/*.hpp)\n"
                             "add_executable(simulator ${sources})\n"
                             "target_compile_options(simulator PUBLIC -std=c++2a -Wall -Wfloat-conversion)\n"
                             "target_include_directories(simulator PUBLIC include)\n"
                             "install(TARGETS simulator DESTINATION bin)\n"
                             "install(DIRECTORY resources DESTINATION bin)\n"
                             "set(CPACK_PACKAGE_NAME \"" +
                      name + "\")\n"
                             "set(CPACK_PACKAGE_VERSION \"1.0.0\")\n"
                             "set(CPACK_MONOLITHIC_INSTALL 1)\n"
                             "include(CPack)\n";

    return ret;
}

void Description::CPU::generate()
{

    std::filesystem::copy("resources/", "out/", std::filesystem::copy_options::recursive | std::filesystem::copy_options::overwrite_existing);

    std::filesystem::create_directory("out");
    std::ofstream hpp("out/include/" + name + ".hpp", std::ios::trunc);

    hpp << generateHeader();
    hpp << generateClass();
    hpp.close();

    std::ofstream info("out/include/AddressInfos.hpp", std::ios::trunc);
    info << generateAddressInfos();
    info.close();

    std::ofstream cpp("out/src/" + name + ".cpp", std::ios::trunc);
    cpp << "#include \"" + name + ".hpp\"\n";
    cpp << "#include <stdio.h>\n";
    cpp << "#include <stdlib.h>\n";

    cpp << "bitset " + name + "::get(AddressInfo info)\n"
                              "{\n"
                              "   return get_mem(&memory[0], info);\n"
                              "}\n";
    for (auto i : instructions)
    {
        cpp << "/* " << i.description << "*/\n";
        cpp << i.getFunction(name) << "\n";
    }


    unsigned int max_bits = 0;
    std::map<std::size_t, std::string> instruction_map{};
    for (auto &i : instructions)
    {
        max_bits = std::max(max_bits,i.bits);
        for(auto& code : i.getOPCodes())
            instruction_map[std::stoi(code.c_str(), nullptr, 2)] = "&" + name + "::" + i.name + "<0b"+ code + ">";
    }
    auto array_size = (unsigned int)std::pow(2,max_bits);
    cpp << "Intel4004::op " + name + "::" + "ops["+std::to_string(array_size)+"] = {\n";
    for(auto i = 0u; i < array_size; i++)
    {
        if(instruction_map.contains(i))
            cpp << instruction_map[i];
        else
            cpp << "NULL";

        if(i != array_size -1) cpp << ",\n";
    }



    cpp << "};\n";

    cpp << name + "::" + name + "()\n{\n";
    for (auto &m : external_memory)
    {
        cpp << m.getInit();
    }
    cpp << "\n}\n";

    cpp << generateDisplay();

    cpp << "void " + name + "::simulate(SIZE_T i)\n{\n"
                            "for (;i-->0;)\n"
                            "{\n"
                            "   auto val = fetch();\n"
                            "   if(ops[val.val()] == NULL)\n"
                            "   {\n"
                            "   #ifndef NO_PRINT\n"
                            "   fprintf(stderr, \"%x unknown\\n\", val.val());\n"
                            "   #endif\n"
                            "   break;\n"
                            "   }\n"
                            "   (this->*ops[val.val()])();\n"
                            "}\n";
    cpp << "}\n";

    for (auto m : external_memory)
    {
        cpp << m.getFunction(name);
    }

    cpp << "bitset " + name + "::fetch()\n"
                              "{\n" +
               fetch.getCode(name) +
               "}\n";

    cpp << "void " + name + "::set(bitset data, AddressInfo info)\n{\nset_mem(&memory[0], info, data);\n}\n";
    cpp << "void " + name + "::set(bitset data, bitset& dest)\n{\ndest=data;\n}\n";
    cpp << "void " + name + "::set(bitset data, int num, const AddressInfo* infos)\n{\n"
                            "for(SIZE_T i = num; i --> 0;)\n"
                            "{\n"
                            "set_mem(&memory[0], infos[i], data);\n"
                            "data = data >> infos[i].length;\n"
                            "}\n}\n";

    cpp.close();

    std::ofstream cmake("out/CMakeLists.txt", std::ios::trunc);
    cmake << generateCMakeFile();
    cmake.close();

    // std::ofstream main("out/src/main.cpp", std::ios::trunc);
    // main << generateMainFile();
    // main.close();
}